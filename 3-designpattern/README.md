# 안드로이드 디자인 패턴

안드로이드에서 사용되는 디자인 패턴은 크게 MVC, MVP, MVVM 3가지가 있습니다.

MVC → MVP → MVVM의 순으로 발전에 왔으며, 기본적으로 각 디자인 패턴의 단점인 테스트의 용이성과 중복 코드를 제거하는 등의 방향으로 발전해왔습니다.

3가지의 디자인 패턴은 Model과 View를 어떤 것으로 잇느냐에 따라 달라집니다.

- 모델(Model) : 앱의 **데이터 + 상태 + 비즈니스 로직**입니다. 뷰나 컨트롤러, 프리젠터 등 다른 것과 묶이지 않아 많은 곳에서 재사용할 수 있습니다.
- 뷰(View) : 모델의 표현입니다. UI를 그리고 유저가 앱과 상호작용 할 수 있도록 통신하는 책임을 맡습니다. 뷰는 모델에 종속되지 않게끔 하는 것이 변화에 유연하게 대처할 수 있습니다.

# MVC

- Model-View-Controller 로 이루어진 디자인 패턴 입니다.

    ![https://images.ctfassets.net/emmiduwd41v7/2XWsL8SmQEg24GIegMsOOs/a595a0352d2dd26ead78a338c16b8419/MVCsvg.svg](https://images.ctfassets.net/emmiduwd41v7/2XWsL8SmQEg24GIegMsOOs/a595a0352d2dd26ead78a338c16b8419/MVCsvg.svg)

- 컨트롤러(Controller) : 애플리케이션에서 발생하는 일을 담당하는 컨트롤러 역할입니다. 예를 들면 사용자의 클릭이 들어왔을때, 컨트롤러는 이에 따른 모델의 상호작용을 결정합니다. 그 후 모델에서 데이터가 변화되는 것에 따라 뷰의 상태를 적절하게 업데이트 합니다.
- 웹서버 같은 다른 종류의 애플리케이션에서는 View와 Controller의 경계가 명확하게 주어지기도 하지만, 안드로이드에서는 View와 Controller가 강하게 결합된 형태로 나타납니다.
- 따라서 안드로이드는 컨트롤러가 주로 액티비티나 프래그먼트로 표현됩니다.
- 장점
    - 가장 기본적인 형태기 때문에, 적용이 가장 쉽습니다.
    - 모델과 뷰를 분리해줍니다.
- 단점
    - 컨트롤러에 대해 유닛테스트가 어렵습니다.
    - 컨트롤러가 뷰에 단단히 결합되며, 뷰의 확장일 수도 있습니다.
    - 시간이 지남에 따라 많은 코드가 액티비티나 프래그먼트에 추가되며 파일이 비대해지고, 유지보수가 어려워집니다.

# MVP

- Model-View-Presenter 로 이루어진 디자인 패턴 입니다. 뷰가 MVC 패턴과는 달리 액티비티, 프래그먼트가 뷰로 간주되어집니다.(MVC에선 컨트롤러)

    ![https://images.ctfassets.net/emmiduwd41v7/79cWBA2VhuiuUeK6uu4WAE/59f8d55cd0997100c718e36b84ad2b37/MVPsvg.svg](https://images.ctfassets.net/emmiduwd41v7/79cWBA2VhuiuUeK6uu4WAE/59f8d55cd0997100c718e36b84ad2b37/MVPsvg.svg)

- 프리젠터(Presenter) : 컨트롤러와 비슷한 역할을 하지만, 뷰에 연결되는 것이 아니라 단순한 인터페이스와 구현 클래스입니다. 이를 통해 테스트 용이성을 확보할 수 있고, 액티비티 파일의 코드를 분리할 수 있습니다.
- 프리젠터에서는 가능한한 안드로이드 API를 참조하지 않아야합니다. 안드로이드 API를 참조하게 되면 테스트가 어려워지기 때문에 테스트 용이성이라는 장점이 사라집니다.
- 컨트롤러를 사용할 때보다 각 행동의 의도가 더 단순하고 명확하게 표현됩니다. 뷰에게 무언가를 표시하는 방법을 지시하는 대신, 표시할 데이터만 전달합니다.
- 장점
    - 프리젠터 로직을 쉽게 테스트 할 수 있습니다.
    - 편중되어있던 액티비티/프래그먼트의 코드를 줄일 수 있습니다.
- 단점
    - 기능이 추가되고 시간이 지남에 따라 프리젠터가 비대해지는 경향이 있습니다. 따라서 MVC의 컨트롤러처럼 유지보수가 어려운 프리젠터가 될 수 있습니다.(그래도 MVC보단 덜합니다.)
    - MVC와는 달리 어느정도 학습과 적응이 필요합니다.

# MVVM

- Model-View-ViewModel 로 이루어진 디자인 패턴 입니다. 뷰는 뷰모델에 의해 보여지는 옵저버블 변수와 액션에 유연하게 바인딩됩니다.

    ![https://images.ctfassets.net/emmiduwd41v7/3Zt3epjcm40kYyygqo8kWG/d9bf5bb78a800eb434a1354bc812c15e/MVVMsvg.svg](https://images.ctfassets.net/emmiduwd41v7/3Zt3epjcm40kYyygqo8kWG/d9bf5bb78a800eb434a1354bc812c15e/MVVMsvg.svg)

- 뷰모델(ViewModel) :  모델을 래핑하고, 뷰에 필요한 옵저버블 데이터를 생성합니다. 뷰에 종속되지 않습니다.
- 이전 디자인 패턴들과는 달리 ViewModel은 액티비티나 프래그먼트의 생명주기의 영향을 받지 않고, 하나의 ViewModel은 여러 View와 연결 될 수 있습니다.
- 장점
    - 뷰모델은 뷰에 대한 의존성이 전혀 없으므로 유닛 테스트가 더 쉬워집니다.
    - 하나의 뷰모델을 여러 뷰에서 사용할 수 있으므로 중복코드가 줄어듭니다. 따라서 생산성이 증가합니다.
- 단점
    - 간단한 앱에 적용할 경우 오히려 구성이 더 복잡하고 비효율적으로 앱이 짜여질 수 있습니다.
    - 데이터 바인딩, 라이브 데이터 등 여러 라이브러리에 대한 학습이 충분해야 원활하게 사용이 가능합니다.
    - 가장 학습 난이도가 높은 디자인 패턴입니다.
    - 자바로는 구현이 어려운 경우가 많아 코틀린 사용이 강제되는 경우가 많습니다.

    ---

    이미지 1,2,3 출처 : [https://academy.realm.io/kr/posts/eric-maxwell-mvc-mvp-and-mvvm-on-android/](https://academy.realm.io/kr/posts/eric-maxwell-mvc-mvp-and-mvvm-on-android/)